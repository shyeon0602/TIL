# Javascript

### 🔹 map, filter, reduce 메소드

- map()

  `map()` 메소드는 배열 내 모든 요소 각각에 대하여 주어진 함수를 호출한 결과를 모아 새로운 배열을 반환한다.

  ```js
  arr.map(callback(currentValue, index, array), thisArg);
  ```

  ```js
  const arr1 = [1, 4, 9, 16];

  const map1 = arr1.map((item, index, array) => {
    console.log(item, index, array, this);
    return item * 2;
  });

  console.log(map1);
  ```

- filter()

  `filter()` 메소드는 주어진 함수의 테스트를 통과하는 모든 요소를 모아 새로운 배열로 반환한다.

  ```js
  arr.filter(callback(element, index, array), thisArg);
  ```

  ```js
  const words = [
    "spray",
    "limit",
    "elite",
    "present",
    "exuberant",
    "destruction",
  ];
  const result = words.filter((word) => word.length > 6);

  console.log(result); // ['exuberant', 'destruction', 'present']
  ```

- reduce()

  `reduce()` 메소드는 배열의 각 요소에 대해 주어진 리듀서 함수를 실행하고 하나의 결과값을 반환한다.

  리듀서 함수는 4개의 인자를 가진다.

  1. 누산기(acc): 값이 쌓임
  2. 현재값(cur)
  3. 현재 인덱스(idx)
  4. 원본 배열(src)

  ```js
  [0, 1, 2, 3, 4].reduce((acc, cur, idx, arr) => {
    return acc + cur;
  });
  ```

  ```js
  [0, 1, 2, 3, 4].reduce((acc, cur, idx, arr) => {
    return acc + cur;
  }, 10); // 두번째 인수로 초기값 제공
  ```

  ❗ 초기값을 제공하면 초기값부터 리듀스 함수가 실행된다.

---

### 🔹 deep copy(깊은 복사)

`JSON.parse(JSON.stringify())`를 사용해서 깊은 복사를 할 수 있다.

`structuredClone()` 메서드를 통해 깊은 복사를 진행하기도 한다.

---

### 🔹 IIFE(Immediately Invoked Function Expression)

즉시 실행 함수 표현은 정의되자마자 즉시 실행되는 js 함수를 말한다.

```js
(function () {
  var aName = "barry";
})();

console.log(aName); // error, IIFE 내부에서 정의된 변수는 외부 범위에서 접근x
```

1. 첫번째 소괄호: 전역 선언을 막고, IIFE 내부 안으로 다른 변수 접근 막기
2. 두번째 소괄호: 즉시 실행 함수를 생성하는 괄호, 이를 통해 js엔진은 함수를 즉시 해석 및 실행

```js
var result = (function () {
  var name = "barry";
  return name;
})();

console.log(result); // barry 출력, 함수가 출력되는 것이 아닌 return값이 출력됨
```

    ❗ 이름 없는 함수
      : 함수에 이름이 없으려면 두가지 조건 중 하나 이상을 충족해야 한다.
        1. 함수를 할당받을 변수를 지정
        2. 함수를 즉시 호출

```js
// 함수 즉시 호출 -> 이름 없는 함수 사용 가능
(function (a, b) {
  return a - b;
})(1, 2);
```

---

### 🔹 Intersection observer

무한스크롤이나 뷰포트 포함여부 확인 등을 구별하기 위해서 사용된다.

기본적으로 브라우저 뷰포트와 설정한 요소의 교차점을 관찰하며, 요소가 뷰포트에 포함되지 않는지, 사용자 화면에 지금 보이는 요소인지 아닌지 구별하는 기능을 제공한다.
