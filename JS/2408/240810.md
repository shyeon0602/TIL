# Javascript

### 🔹 this 키워드

- 메소드에서 this 사용

  메소드는 객체 안에 위치한 함수를 말한다.<br>
  메소드에서 `this` 키워드를 사용하면 해당 객체를 가리킨다.

  ```js
  // method -> object
  const audio = {
    title: "a",
    play() {
      console.log("play this", this);
    },
  };

  audio.play();

  audio.stop = () => {
    console.log("stop this", this);
  };
  ```

- 함수에서의 this 사용

  함수 내에서 `this`를 사용하면 윈도우 객체를 호출한다.

  ```js
  // function -> window object
  function playAudio() {
    console.log(this);
  }

  playAudio(); // 함수를 호출하면 함수 내에서 this는 윈도우 객체를 호출
  ```

- constructor 함수

  ```js
  function Audio(title) {
    this.title = title; // 객체 title 생성
    console.log(this);
  }

  const audio = new Audio("a"); // 생성자 호출
  ```

각 블록마다 `this` 키워드가 적용되는 범위가 다르다.

```js
const audio = {
  title: "audio",
  categories: ["rock", "pop", "hiphop", "jazz"],
  displayCategories() {
    this.categories.forEach(
      function (category) {
        console.log(`title: ${this.title}, category: ${category}`); // 이렇게만 작성하면 this.title은 객체의 title을 참조하지 않고 window 객체를 참조함
      },
      { title: "audio" } // 따라서 함수 내에서 객체 title을 명시해줘서 콜백함수에서 this로 참조할 수 있게 함, 또는 이 부분에서 this로 작성하면 객체를 참조하기 때문에 동일한 결과가 나옴
    );
  },
};
```

- 화살표함수 this 키워드

  화살표 함수에서 사용된 `this` 키워드는 항상 상위스코프 this를 가리키게 된다.

  ```js
  const audio = {
    title: "audio",
    categories: ["rock", "pop", "hiphop", "jazz"],
    displayCategories() {
      this.categories.forEach((category) => {
        console.log(this); // 객체 title을 가리킴
      });
    },
  };
  ```

---

함수에서 `this` 키워드를 사용했을 때 윈도우 객체가 참조되는 것을 방지하기 위해서 `call()` 메소드, `bind()` 메소드, `apply()` 메소드를 사용할 수 있다.

- call() 메소드

  `call` 메소드는 함수를 호출하는 함수이다. 첫번째 매개변수로 값을 전달하면 호출되는 함수의 this 안에 전달받은 것을 받게 된다.

  ```js
  const fullName = function (city, country) {
    console.log(this.firstName + " " + this.lastName, city, country);
  };

  const person1 = {
    firstName: "john",
    lastName: "smith",
  };

  fullName.call(person1, "oslo", "norway");
  ```

- apply() 메소드

  `apply` 메소드는 call 메소드와 유사하지만 프로퍼티를 입력할 때 배열로 넣는다.

  ```js
  const fullName = function (city, country) {
    console.log(this.firstName + " " + this.lastName, city, country);
  };

  const person1 = {
    firstName: "john",
    lastName: "smith",
  };

  fullName.apply(person1, ["oslo", "norway"]);
  ```

- bind() 메소드

  객체를 바인딩만 해주고 함수 호출은 안되기 때문에 위 두개의 메소드와 달리 함수 호출을 별도로 해줘야 한다.

  ```js
  function func(language) {
    if (language == "kor") {
      console.log(`language: ${this.korGreeting}`);
    } else {
      console.log(`language: ${this.engGreeting}`);
    }
  }

  const greeting = {
    korGreeting: "안녕 ",
    engGreeting: "hello ",
  };

  // const boundFunc = func.bind(greeting);
  // boundFunc("kor");

  const boundFunc = func.bind(greeting)("kor"); // 이렇게 바로 호출도 가능
  ```

---

### 🔹 Event Loop

- setTimeout()

  전역 `setTimeout()` 메서드는 만료된 후 함수나 지정한 코드 조각을 실행하는 타이머를 설정한다.

  두번째 매개변수로 들어간 밀리초 단위가 지난 후 첫번째 매개변수인 콜백함수가 호출된다.

💡 동기 vs 비동기

- 동기<br>
  : 시간을 맞춤, 순서대로 진행됨, 먼저 이전의 것이 끝나야 다음 것을 할 수 있다.

- 비동기<br>
  : 시간을 맞추지 않음, 병행하면서 작동할 수 있다.

  자바스크립트는 동기 언어이다. 비동기 코드를 작성하기 우해서는 자바스크립트 이외의 도움을 받는다. 브라우저에서 사용을 한다면 브라우저 api(window object)를 사용하는 것이고, node에서 사용한다면 node api(global object)를 사용하는 것이다.

  - 자바스크립트 엔진<br>
    : 자바스크립트 코드를 실행하려면 js 엔진이 필요하다. 엔진은 두가지 요소로 구성된다.

    1. 메모리 힙: 메모리 할당이 발생하는 곳, 변수를 정의하면 저장이 되는 창고

    2. 호출 스택: 코드가 실행될 때 스택이 이곳에 쌓임

    호출스택에 오기 전 web api에 저장되어 있다가 콜백 큐로 갔다가 호출스택이 비었을 때 호출스택에서 실행된다.

---
